<html>
<head>
<title>Infinite tunnel</title>

<!--<script src="three.js-master/build/three.js"></script>-->
<script src="js/three_with_FogExp.js"></script>
<!--<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>-->
</head>

<body>

<nav style="position: absolute; top:0; left:0, height:2vh; z-index:999">
	<a href="." style="color: #66ffff">Back to index.</a>
</nav>

<script>
/*


TODO:
- Efficient representation with fewer draw calls, using merging, render groups, instancing etc.
- Physical materials? EnvMap could perhaps be from cubecamera?
- Gameplay based on other cars that copy/rotate/mirror/slow own movement, and score that depends on max speed, survival time and distance travelled.

For another(?) game:
- Realistic vehicle physics.
- Twists and turns, based on permuting a fixed set of tunnel segments. Can use Object3D.attach to seamlessly build an "infinite-depth" scene graph.
- Proper collision detection. I was/am planning to make the collision detection analytical by applying transforms from arbitrary positions back to a manageable coordinate system. I would manage to do that with straight lines and circle curves, but maybe not for general curves. I am probably going for another solution based on library functions, such as Curve and ExtrudedBufferGeometry.
See: https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas
*/

//Units are base SI.

class TunnelRoad extends THREE.Group {
	constructor() {
		super();
		
		//Constants:
		const radius = TunnelRoad.radius;
		const dirSegments = TunnelRoad.dirSegments;
		const archAngle = TunnelRoad.archAngle;
		const segmentLength = TunnelRoad.segmentLength;
		const roadWidth = TunnelRoad.roadWidth;
		const shoulderProportion = TunnelRoad.shoulderProportion;
		const angle_down_from_road = TunnelRoad.angle_down_from_road;
		
		
		const tunnelSegment = new THREE.Group();
		tunnelSegment.position.y=radius*Math.cos(angle_down_from_road);

		const lightCeilingMat = new THREE.MeshPhongMaterial( {map: TunnelRoad.lightTileMap, side: THREE.BackSide, bumpMap: TunnelRoad.tileBumpMap, bumpScale: 0.04, fog: true} );
		const darkCeilingMat = new THREE.MeshPhongMaterial( {map: TunnelRoad.darkTileMap, side: THREE.BackSide, bumpMap: TunnelRoad.tileBumpMap, bumpScale: 0.04, fog: true} );
		
		const tilesLeft = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(radius, radius, segmentLength, 7, 1, true, Math.PI+angle_down_from_road, archAngle/3),
			lightCeilingMat
		);
		tunnelSegment.add(tilesLeft);
		
		const tilesTop = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(radius, radius, segmentLength, 8, 1, true, Math.PI+angle_down_from_road+archAngle/3, archAngle/3),
			darkCeilingMat
		);
		let uva = tilesTop.geometry.attributes.uv.array;
		for (let i = 0; i < uva.length; i+=2) {
			uva[i] = uva[i]*8/7;
		}
		tilesTop.geometry.attributes.uv.needsUpdate = true;
		tunnelSegment.add(tilesTop);
		
		const tilesRight = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(radius, radius, segmentLength, 7, 1, true, Math.PI+angle_down_from_road+2*archAngle/3, archAngle/3),
			lightCeilingMat
		);
		tunnelSegment.add(tilesRight);

		var lightRail = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(0.2, segmentLength),
			new THREE.MeshPhongMaterial( {color: 0x333333, fog: true, side: THREE.BackSide} )
		);
		lightRail.name = "lightRail";
		//lightRail.rotation.y = Math.PI;
		lightRail.position.z = (radius-0.1);
		tunnelSegment.add(lightRail);

		var ceilLight = new THREE.Mesh(
			new THREE.BoxBufferGeometry(0.4, 0.4, 0.2),
			new THREE.MeshPhongMaterial( {
				color: 0xcccc00,
				emissive: 0xffffaa,
				//side: THREE.BackSide
				fog: true
				} )
		);
		ceilLight.position.z = -0.1;
		
		for (var y = -segmentLength/2; y < segmentLength/2; y += 18) {
			var cl = ceilLight.clone();
			cl.position.y = y;
			//let ang = 2*(Math.random()-0.5)*Math.PI/12;
			//cl.rotation.y = ang;
			lightRail.add(cl);
			
			let sl = new THREE.SpotLight(0xffffaa, 50, 0, 0.5*Math.PI, 0.5, 2);
			sl.target.position.z = -100000000;
			cl.add(sl);
		}
		
		const roadSegment = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(2*radius*Math.sin(angle_down_from_road), segmentLength),
			new THREE.MeshPhongMaterial( {
				color: 0x444444,
				//side: THREE.BackSide,
				bumpMap: TunnelRoad.asphaltBumpMap,
				bumpScale: 0.01,
				fog: true
			} )
		);
		roadSegment.rotation.x=Math.PI/2;
		roadSegment.rotation.y=Math.PI;
		
		var stripeWidth = 0.15;
		
		var stripe = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(stripeWidth, 9),
			new THREE.MeshPhongMaterial( {color: 0xcccc00, emissive: 0xcccc00, emissiveIntensity: 0.025, fog: true})//, side: THREE.BackSide} )
		);
		stripe.position.z = 0.1;
		
		for (var y = -segmentLength/2; y < segmentLength/2; y += 12) {
			let s = stripe.clone();
			roadSegment.add(s);
			s.position.y = y;
		}
		
		//New definition:
		stripe = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(stripeWidth, segmentLength),
			new THREE.MeshPhongMaterial( {color: 0xeeeeee, emissive: 0xeeeeee, emissiveIntensity: 0.025, fog: true})//, side: THREE.BackSide} )
		);
		stripe.position.z = 0.1;
		stripe.position.x = (roadWidth/2)*(1-shoulderProportion);
		roadSegment.add(stripe);
		stripe = stripe.clone();
		stripe.position.x = -(roadWidth/2)*(1-shoulderProportion);
		roadSegment.add(stripe);
		
		roadSegment.add(tunnelSegment);

		//Join segments:
		for (let i = -(dirSegments-1); i < dirSegments; i++) {
			let seg = roadSegment.clone();
			seg.position.z = i*segmentLength;
			this.add(seg);
		}
		
		for (let seg of this.children) {
			let lightRail = seg.getObjectByName("lightRail");//children[5].children[0];
			for (let cl of lightRail.children) {
				let sl = cl.children[0];
				cl.add(sl.target);
			}
		}
	}
}

// CONSTANTS //
{
//Road dimensions are according to Norwegian standard. :)
//Could have been parameters, but are needed for textures
Object.assign(TunnelRoad, {
	radius: 4.1,
	dirSegments: 20,
	archAngle: Math.PI*5/4, //almost Arch angel
	segmentLength: 36, // m
	shoulderProportion: 0.18
});
//Computed constants:
TunnelRoad.angle_down_from_road = (2*Math.PI-TunnelRoad.archAngle)/2;
TunnelRoad.roadWidth = 2*TunnelRoad.radius*Math.sin(TunnelRoad.angle_down_from_road);
}

// DATA TEXTURES //
{
	const radius = TunnelRoad.radius;
	const dirSegments = TunnelRoad.dirSegments;
	const archAngle = TunnelRoad.archAngle;
	const segmentLength = TunnelRoad.segmentLength;
	const angle_down_from_road = TunnelRoad.angle_down_from_road;

	//Generate tile textures and bump map
	var tileData = new Uint8Array(3*256*128);
	var darkData = new Uint8Array(3*256*128);
	var tileBumpData = new Uint8Array(3*256*128);
	var pos=0, lum, dark, bump;
	for (var i=0; i<256; i++) {
		for (var j=0; j<128; j++) {
			if (i===0 || i===255 || 
				j===0 || j===127) {
				lum = 128;
				dark = 64;
				bump = 0;
			} else {
				lum = 200;
				dark = 100;
				let x = (i-128)/128;
				let y = (j-64)/64;
				let r = (x**2+y**2)**0.5/Math.sqrt(2);
				let theta = Math.atan2(y,x);
				bump = 72 + 55*Math.cos(0.5*Math.PI*r)*(1-r**2*0.1*0.5*(1+Math.sin(8*theta/2*Math.PI)));
			}
			tileData[pos] = lum; //r
			tileData[pos+1] = lum; //g
			tileData[pos+2] = lum; //b	
			darkData[pos] = dark; //r
			darkData[pos+1] = dark; //g
			darkData[pos+2] = dark; //b	
			tileBumpData[pos] = bump; //r
			tileBumpData[pos+1] = bump; //g
			tileBumpData[pos+2] = bump; //b	
			pos += 3;
		}
	}

	var lightTileMap = new THREE.DataTexture(
		tileData,
		128,256,
		THREE.RGBFormat,
		undefined, undefined,
		THREE.RepeatWrapping, THREE.RepeatWrapping,
		THREE.NearestFilter,
		THREE.LinearMipmapLinearFilter,
		1);
	lightTileMap.generateMipmaps = true;
	//Make tiles approx. proportional:
	lightTileMap.repeat.set(7, Math.round(11*segmentLength/(radius*archAngle)));
	lightTileMap.needsUpdate = true;

	var darkTileMap = new THREE.DataTexture(
		darkData,
		128,256,
		THREE.RGBFormat,
		undefined, undefined,
		THREE.RepeatWrapping, THREE.RepeatWrapping,
		THREE.NearestFilter,
		THREE.LinearMipmapLinearFilter,
		1);
	darkTileMap.generateMipmaps = true;
	//Make tiles approx. proportional:
	darkTileMap.repeat.set(7, Math.round(11*segmentLength/(radius*archAngle)));
	darkTileMap.needsUpdate = true;
	
	var tileBumpMap = new THREE.DataTexture(
		tileBumpData,
		128,256,
		THREE.RGBFormat,
		undefined, undefined,
		THREE.RepeatWrapping, THREE.RepeatWrapping,
		THREE.LinearFilter,
		THREE.LinearMipmapLinearFilter,
		1);
	tileBumpMap.generateMipmaps = true;
	//Make tiles approx. proportional:
	tileBumpMap.repeat.set(7, Math.round(11*segmentLength/(radius*archAngle)));
	tileBumpMap.needsUpdate = true;

	//Asphalt surface
	let bumpSide = 128;
	bumpData = new Uint8Array(3*bumpSide*bumpSide);
	for (var i=0; i<3*bumpSide*bumpSide; i+=3) {
		bumpData[i] = Math.floor(Math.random()*256);
	}
	let repU = Math.round(100*2*radius*Math.sin(angle_down_from_road)/bumpSide);
	let repV = Math.round(100*segmentLength/bumpSide);
	/*var asphaltMap = new THREE.DataTexture(
		bumpData,
		64,64,
		THREE.RGBFormat);
	asphaltMap.wrapS = THREE.RepeatWrapping;
	asphaltMap.wrapT = THREE.RepeatWrapping;
			//golden ratio between asphaltBumpMap repeat and asphaltMap repeat (DOESN'T WORK! Must use custom shader for this. Should also use high-res phi.)
	asphaltMap.repeat.set(Math.round(0.618*repU),
					Math.round(0.618*repV));
	asphaltMap.needsUpdate = true; //test*/
	
	var asphaltBumpMap = new THREE.DataTexture(
	//data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy 
		bumpData,
		bumpSide,bumpSide,
		THREE.RGBFormat,
		undefined, undefined,
		THREE.RepeatWrapping, THREE.RepeatWrapping,
		THREE.LinearFilter,
		THREE.LinearMipmapLinearFilter,
		1);
	asphaltBumpMap.generateMipmaps = true;
	asphaltBumpMap.repeat.set(repU, repV);
	asphaltBumpMap.needsUpdate = true; //test
	
	Object.assign(TunnelRoad, {
		lightTileMap,
		darkTileMap,
		tileBumpMap,
		//asphaltMap,
		asphaltBumpMap
	});
}
// END DATA TEXTURES //

class Car extends THREE.Group {
	constructor(width=1.6, length=4, height=0.8) {
		super();
		
		this.width = width;
		this.length = length;
		this.height = height;
		
		//this.velocity = new THREE.Vector3(0,0,0);
		this.speed = 0;
		//this.acceleration = new THREE.Vector3(0,0,0);
		//this.mass = 1500; //kg
		//this.rolling_friction = 0.01;
		//this.grip = 0.5; //applies all ways. interpret as friction coefficient.
		//this.wheelMomentum = 0;
		//this.power = 300000; //W
		this.m = 1500;
		this.I = this.m*(Math.pow(width, 3)*Math.pow(length, 4)+Math.pow(length, 3)*Math.pow(width, 4))/12;

		this.axle_distance = length;
		this.wheelAngle = 0;
		this.driverSkew = 0.45;
		this.eyeHeight = 0.8;

		this.dashCam = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, TunnelRoad.dirSegments*TunnelRoad.segmentLength);
		this.dashCam.position.set(this.driverSkew,this.eyeHeight,0);
		this.dashCam.lookAt(new THREE.Vector3(this.driverSkew,this.eyeHeight,TunnelRoad.segmentLength));
		this.add(this.dashCam);

		//Headlights:
		{
			let interval = width;
			this.headLightInterval = interval;
			let altitude = 0.8;
			let distance = 1.3;
			let range = 250;
			let angle = 0.1;
			
			var left = new THREE.SpotLight(0xffffff, 400, range, Math.PI/8, 0.2, 2);
			left.position.set((-interval/2),altitude, distance);
			left.target.position.set((-interval/2),altitude-0.001-Math.sin(angle), distance+0.001+Math.cos(angle));
			this.add(left);

			var right = left.clone();
			right.position.x = (interval/2);
			right.target.position.x = (interval/2);
			this.add(right, left.target, right.target);
		}
	}
	update(pedals, steering_wheel, dt) {
		// Simplified calculation
		//let steering response depend on speed, because of the limitations of the steering wheel.
		this.wheel_angle = Math.abs(this.speed)<=1 ? steering_wheel*(Math.PI/2.2) : steering_wheel*Math.PI/(2.2*Math.abs(this.speed));
		var AF = 12; //max acceleration forward
		var AR = 6; //max acceleration in reverse
		var B = 20; //max braking
		var C = 0.1; //max constant friction loss
		var D = 0.05; //linear friction loss
		var E = 0.002; //quadratic friction loss
		var accbr = ((this.speed>=0)*((AF*(pedals>=0)+B*(pedals<0)))
					+(this.speed<0)*((B*(pedals>=0)+AR*(pedals<0))))*pedals
					- (Math.abs(this.speed)>=C*dt)*Math.sign(this.speed)*C
					- Math.sign(this.speed)*D*this.speed
					- Math.sign(this.speed)*E*this.speed*this.speed;
		//Maximum forward speed is at equilibrium:
		//AF-C-D*vmax-E*vmax^2=0 ==> vmax = (-D+sqrt(D^2+4(AF-C)*E))/2E ~= 65.6 m/s
		this.speed += accbr*dt;
		if (Math.abs(this.speed)<C*dt) this.speed = 0;
		//I calculate the turning TunnelRoad.radius from cord length (this.axle_distance) and cord angle (this.wheel_angle),
		//by exploiting that halving both yields a right-angled triangle.
		var turning_radius = this.axle_distance/(2*Math.sin(this.wheel_angle/2))
		//console.log(turning_radius); //OK
		this.rotation.y += this.speed*dt/turning_radius; //theta = s/r
		var heading = new THREE.Vector3();
		this.getWorldDirection(heading);
		this.position.addScaledVector(heading,this.speed*dt);
		
		//var speed = this.velocity.length(); //probably need velocity decomposed in this direction and perpendicular to it.

		//For more physically correct calculation with friction and everything (more work, obviously)
		//this.acceleration = heading.multiplyScalar(accbreak);//.addScaledVector(
								//);
		//this.velocity.addScaledVector(this.acceleration, dt);
		//this.position.addScaledVector(this.velocity, dt);

		//alpha = -(0.05+(Math.random()-0.5)/100)*this.rotation.z;
		//omega += alpha*dt;
		//this.rotation.z += omega*dt;
	}
}

//For keyboard control
var arrow_keys = [false, false, false, false];
document.onkeydown = function(e) {
	if (37 <= e.keyCode && e.keyCode <=40) {
		arrow_keys[e.keyCode-37] = true;
		//console.log("key %d down", e.keyCode);
	}
}
document.onkeyup = function(e) {
	if (37 <= e.keyCode && e.keyCode <=40) {
		arrow_keys[e.keyCode-37] = false;
		//console.log("key %d up", e.keyCode);
	}
}

var container, renderer, scene, segmentLength, road, car, camera, gamePads;
var omega, alpha;

// INIT //
{
	document.body.style.overflow = "hidden";
	container = document.createElement("div");
	Object.assign(container.style, {
		position: "absolute",
		top: 0,
		left: 0,
		width: "100vw",
		height: "100vh"
	});
	document.body.appendChild(container);
	renderer = new THREE.WebGLRenderer( {antialias: true} );
	renderer.physicallyCorrectLights = true;
	renderer.setPixelRatio(window.devicePixelRatio);
	container.appendChild(renderer.domElement);
	
	const fogColor = 0x777766;
	renderer.setClearColor(fogColor);
	scene = new THREE.Scene();
	
	road = new TunnelRoad();
	scene.add(road);

	const fogDensity = Math.log(512)/(TunnelRoad.dirSegments*TunnelRoad.segmentLength);
	scene.fog = new THREE.FogExp(fogColor, fogDensity);//0.001);//new THREE.Fog(fogColor, 0, (TunnelRoad.dirSegments-1)*36);
	
	car = new Car();
	car.position.set(-TunnelRoad.roadWidth*(1-TunnelRoad.shoulderProportion)/4,car.height/2,0);
	scene.add(car);
	
	camera = car.dashCam;
	
	function onWindowResize() {
		let w = container.clientWidth;
		let h = container.clientHeight;
		renderer.setSize(w, h);
		camera.aspect = w / h;
		camera.updateProjectionMatrix();
	}
	window.addEventListener('resize', onWindowResize, false);
	onWindowResize();

	//Game loop:
	var ot = performance.now();
	requestAnimationFrame(
	function animate(mt) {
		var dt = 0.001*(mt-ot);
		ot = mt;
		
		gamePads = navigator.getGamepads();
		if (gamePads[0]) {
			// Read and filter controller state
			var steering_wheel = -gamePads[0].axes[0];
			// if (Math.abs(steering_wheel)<0.1) steering_wheel = 0;
			// else steering_wheel -= 0.1*Math.sign(steering_wheel);
			var pedals = -gamePads[0].axes[1];
			if (Math.abs(pedals)<0.1) pedals = 0;
			else pedals -= 0.1*Math.sign(pedals);
		} else {
			//use arrow keys instead
			pedals = 1*arrow_keys[1]-1*arrow_keys[3];
			steering_wheel = 1*arrow_keys[0]-1*arrow_keys[2];
		}
		
		car.update(pedals, steering_wheel, dt);
		//rudimentary crash handling.
		if (Math.abs(car.position.x) > (TunnelRoad.radius-0.5*car.width)) {
			car.position.x = Math.sign(car.position.x)*(TunnelRoad.radius-0.5*car.width-0.1);
			car.speed*=0.2;
			car.rotation.y = Math.round(((car.rotation.y)%(2*Math.PI))/Math.PI)*Math.PI;
		}

		//Infinite tunnel effect:
		car.position.z -= Math.sign(car.position.z)*Math.floor(Math.abs(car.position.z)/36)*36;
		
		renderer.render(scene, camera);
		requestAnimationFrame(animate);
	});
}
</script>
</body>
</html>